# standard imports
from collections import namedtuple

# third-party imports
import numpy as np
from orsopy.fileio.orso import load_orso, save_nexus, Orso, OrsoDataset, Column, ErrorColumn
from orsopy.fileio.base import ErrorValue, Value
from orsopy.fileio.data_source import InstrumentSettings
import pytest

# refl1d imports
from refl1d import probe
from refl1d.probe.data_loaders.load4 import parse_orso, load4, sigma2FWHM, FWHM2sigma


OrsoFiles = namedtuple("OrsoFiles", ["ort", "orb"])
ArrayTOrsoFiles = namedtuple("ArrayTOrsoFiles", ["scalar_dT", "array_dT"])


@pytest.fixture
def orsofiles(tmp_path):
    """
    Pytest fixture to create temporary ORSO files for testing.

    This fixture creates two temporary files: one with a `.ort` extension and one with a `.orb` extension.
    The `.ort` file is written with a sample ORSO entry, and the `.orb` file is generated by converting the `.ort` file
    using the `save_nexus` function from the `orsopy.fileio.orso` module. The paths to these files are yielded as a
    namedtuple `OrsoFiles` containing `ort` and `orb` attributes.

    Yields
    ------
    OrsoFiles
        A namedtuple containing the paths to the temporary `.ort` and `.orb` files.
    """

    entry = """# # ORSO reflectivity data file | 1.0 standard | YAML encoding | https://www.reflectometry.org/
# data_source:
#   owner:
#     name: Artur Glavic
#     affiliation: null
#     contact: b''
#   experiment:
#     title: Structural evolution of the CO2/Water interface
#     instrument: Amor
#     start_date: 2023-11-29T10:12:45
#     probe: neutron
#     facility: SINQ@PSI
#     proposalID: '20230368'
#   sample:
#     name: prist4
#     sample_parameters:
#       tempMean: {magnitude: -9999.0}
#     model:
#       stack: vacuum | Al2O3 2 | Ti0.27Co0.73 9.3 | Si
#   measurement:
#     instrument_settings:
#       incident_angle: {magnitude: 0.08, error: 0.01, unit: deg}
#       wavelength: {magnitude: 7.5, error: 4.5, unit: angstrom}
#       polarization: pp
#     data_files:
#     - file: raw/amor2023n000848.hdf
#       timestamp: 2023-11-29T10:12:45
#       amor_monitor: 1792.443302905
#     scheme: angle- and energy-dispersive
#     references: []
#     amor_monitor: 1792.443302905
# reduction:
#   software: {name: eos, version: '2.0'}
#   timestamp: 2023-11-29T10:57:48.480339
#   computer: amor.psi.ch
#   call: eos.py -a 0.04 -F 0.0093,0.0101 -n 848 prist5_10K_m_025
# data_set: 0
# columns:
# - {name: Qz, unit: 1/angstrom, physical_quantity: normal momentum transfer}
# - {name: R, unit: '', physical_quantity: specular reflectivity}
# - {error_of: R, error_type: uncertainty, value_is: sigma}
# - {error_of: Qz, error_type: resolution, value_is: sigma}
# # Qz (1/angstrom)    R ()                   sR                     sQz
2.1999999999999997e-03 4.7241193897215048e-03 4.7241193897215048e-03 1.9999999999999987e-04
2.5999999999999999e-03 0.0000000000000000e+00 0.0000000000000000e+00 2.0000000000000009e-04
3.0000000000000001e-03 4.9441079014990305e-03 2.8632759811688313e-03 2.0000000000000009e-04
3.4000000000000002e-03 5.3957146642147798e-03 2.7033018099334193e-03 1.9999999999999987e-04
3.8000000000000000e-03 1.1948517768746966e-02 3.7903477990210636e-03 2.0000000000000009e-04
4.2000000000000006e-03 1.6302332669940297e-02 3.9723175648453228e-03 2.0000000000000009e-04
4.5999999999999999e-03 2.2652164871650581e-02 4.5763672802481776e-03 2.0000000000000009e-04
5.0000000000000001e-03 2.3020814468949415e-02 4.2537271133726200e-03 1.9999999999999966e-04
5.4000000000000003e-03 2.7305557750665344e-02 4.4287009711273589e-03 2.0000000000000009e-04
5.7999999999999996e-03 1.9457945835850306e-02 3.7817426451169783e-03 2.0000000000000009e-04
6.2000000000000006e-03 2.7645506109865266e-02 4.2679939914090732e-03 2.0000000000000009e-04
6.6000000000000000e-03 2.4223034347324195e-02 3.7655052701117517e-03 2.0000000000000009e-04
7.0000000000000001e-03 2.8408308819418325e-02 3.7377941755602716e-03 1.9999999999999966e-04
7.4000000000000003e-03 5.7460495308053604e-02 5.2154049057105455e-03 2.0000000000000009e-04
7.7999999999999996e-03 1.4898833519509819e-01 7.5478984035617898e-03 2.0000000000000009e-04
8.1999999999999990e-03 3.5204809294430212e-01 1.1146891694516669e-02 1.9999999999999966e-04
8.6000000000000000e-03 5.3176577607895481e-01 1.3517251795319620e-02 1.9999999999999966e-04
"""
    ort_file = tmp_path / "test.ort"
    ort_file.write_text(entry)
    ort_file_path = str(ort_file)
    orb_file_path = str(tmp_path / "test.orb")
    save_nexus(load_orso(ort_file_path), orb_file_path)
    yield OrsoFiles(ort=ort_file_path, orb=orb_file_path)


@pytest.fixture
def theta_column_orso_files(tmp_path):
    # Generate files with different T and dT formats

    orso_obj = Orso.empty()
    orso_obj.columns = [
        Column(name="Qz", unit="1/angstrom", physical_quantity="normal momentum transfer"),
        Column(name="R", unit="", physical_quantity="specular reflectivity"),
        ErrorColumn(error_of="R", error_type="uncertainty", value_is="sigma"),
        ErrorColumn(error_of="Qz", error_type="resolution", value_is="sigma"),
        Column(name="theta", unit="degrees", physical_quantity="incident_angle"),
        # ErrorColumn(error_of="theta", error_type="resolution", value_is="sigma"),
    ]
    # Create test data
    Qz = np.array([0.01, 0.02, 0.03, 0.04])
    R = np.array([1.0, 0.8, 0.6, 0.4])
    dR = np.array([0.1, 0.08, 0.06, 0.04])
    dQ = np.array([0.001, 0.002, 0.003, 0.004])
    T = np.array([0.005, 0.010, 0.015, 0.020])  # Array of angles
    dT_array = np.array([0.001, 0.002, 0.003, 0.004])  # Array of angular resolutions
    dT_scalar = 0.001  # Scalar angular resolution, FWHM, in degrees
    dLoL_target = 1e-4  # expected output of dQdT2dLoL
    T_rad = np.radians(T)

    # Set up dQ for scalar dT
    dT_scalar_rad = np.radians(dT_scalar)
    dQoQ_scalar = np.sqrt(dT_scalar_rad**2 / np.tan(T_rad) ** 2 + dLoL_target**2)
    dQ_scalar_FWHM = dQoQ_scalar * Qz
    dQ_scalar_sigma = FWHM2sigma(dQ_scalar_FWHM)

    # Set up dQ for array dT
    dQoQ_array = np.sqrt((np.radians(dT_array) / np.tan(T_rad)) ** 2 + dLoL_target**2)
    dQ_array_FWHM = dQoQ_array * Qz
    dQ_array_sigma = FWHM2sigma(dQ_array_FWHM)

    dT_errorvalue = ErrorValue(error_value=dT_scalar, value_is="FWHM", error_type="resolution", distribution="gaussian")
    dL_errorvalue = ErrorValue(error_value=None, value_is="sigma", error_type="resolution", distribution="gaussian")
    instrument_settings = InstrumentSettings(
        incident_angle=Value(magnitude=float(np.mean(T)), error=dT_errorvalue, unit="deg"),
        wavelength=Value(magnitude=None, error=dL_errorvalue, unit="angstrom"),
    )
    orso_obj.data_source.measurement.instrument_settings = instrument_settings

    # create dataset with scalar dT
    orso_dataset = OrsoDataset(orso_obj, np.vstack((Qz, R, dR, dQ_scalar_sigma, T)).T)
    scalar_dT_filename = "test_t_array_dt_scalar.ort"
    orso_dataset.save(tmp_path / scalar_dT_filename)

    # add dT as column
    orso_obj.columns.append(ErrorColumn(error_of="theta", error_type="resolution", value_is="FWHM"))
    # create new dataset with dT as array
    orso_dataset = OrsoDataset(orso_obj, np.vstack((Qz, R, dR, dQ_array_sigma, T, dT_array)).T)
    array_dT_filename = "test_t_array_dt_array.ort"
    orso_dataset.save(tmp_path / array_dT_filename)

    yield ArrayTOrsoFiles(
        scalar_dT=str(tmp_path / scalar_dT_filename),
        array_dT=str(tmp_path / array_dT_filename),
    )


def test_parse_orso(orsofiles):
    ortset = parse_orso(orsofiles.ort)

    # Check the length of the sets
    assert len(ortset) == 1

    # Check the structure of the first entry
    header, data = ortset[0]

    # Check the header dictionary
    assert isinstance(header, dict)
    assert header["polarization"] == "++"
    header_values = {
        "angle": 0.08,
        "angular_resolution": 0.01,
        "wavelength": 7.5,
        "wavelength_resolution": 4.5,
    }
    for key, value in header_values.items():
        assert key in header
        assert np.isclose(header[key], value)

    # Check the data array
    assert isinstance(data, np.ndarray)
    assert data.shape == (4, 17)

    # Check that parse_orso returns the same data for both ort and orb files
    orbset = parse_orso(orsofiles.orb)
    header_other, data_other = orbset[0]
    assert header == header_other
    assert np.allclose(data, data_other)


def test_T_dT_data_range(theta_column_orso_files):
    """Test that T and dT are correctly read from Orso files with different formats."""
    # Load the probe from the .ort file with dT as scalar
    scalar_dT_file = theta_column_orso_files.scalar_dT
    probe_scalar_dT = load4(scalar_dT_file, radiation="neutron")
    assert np.allclose(probe_scalar_dT.T, [0.005, 0.010, 0.015, 0.020])
    assert np.allclose(probe_scalar_dT.dL / probe_scalar_dT.L, 1e-4)  # dL/L should match target
    assert np.allclose(probe_scalar_dT.dT, [0.001, 0.001, 0.001, 0.001])  # dT should be broadcasted
    expected_L = 4 * np.pi * np.sin(np.radians(probe_scalar_dT.T)) / probe_scalar_dT.Q
    assert np.allclose(probe_scalar_dT.L, expected_L)
    assert len(probe_scalar_dT.dL) == len(probe_scalar_dT.Q)

    # Load with data_range
    probe_scalar_dT_range = load4(scalar_dT_file, radiation="neutron", data_range=(1, -1))
    assert np.allclose(probe_scalar_dT_range.T, [0.010, 0.015])
    assert np.allclose(probe_scalar_dT_range.dT, [0.001, 0.001])  # dT should be broadcasted
    expected_L_scalar_range = 4 * np.pi * np.sin(np.radians(probe_scalar_dT_range.T)) / probe_scalar_dT_range.Q
    assert np.allclose(probe_scalar_dT_range.L, expected_L_scalar_range)
    assert len(probe_scalar_dT_range.dL) == len(probe_scalar_dT_range.Q)

    # Load the probe from the .ort file with dT as array
    array_dT_file = theta_column_orso_files.array_dT
    probe_array_dT = load4(array_dT_file, radiation="neutron")
    assert np.allclose(probe_array_dT.T, [0.005, 0.010, 0.015, 0.020])
    assert np.allclose(probe_array_dT.dT, [0.001, 0.002, 0.003, 0.004])  # dT should match input array
    assert np.allclose(probe_array_dT.dL / probe_array_dT.L, 1e-4)  # dL/L should match target
    expected_L_array = 4 * np.pi * np.sin(np.radians(probe_array_dT.T)) / probe_array_dT.Q
    assert np.allclose(probe_array_dT.L, expected_L_array)
    assert len(probe_array_dT.dL) == len(probe_array_dT.Q)

    # Load with data range
    probe_array_dT_range = load4(array_dT_file, radiation="neutron", data_range=(1, -1))
    assert np.allclose(probe_array_dT_range.T, [0.010, 0.015])
    assert np.allclose(probe_array_dT_range.dT, [0.002, 0.003])  # dT should match input array
    expected_L_array_range = 4 * np.pi * np.sin(np.radians(probe_array_dT_range.T)) / probe_array_dT_range.Q
    assert np.allclose(probe_array_dT_range.L, expected_L_array_range)  # dL/L should match target
    assert len(probe_array_dT_range.dL) == len(probe_array_dT_range.Q)
